// needs RAT.jsfunction CF(){   this.cf=new Array(); // cf[0] is always the integer part   this.cfrec=new Array();   this.cvgt=new Array();   this.stopped=false; this.cfOFLO=false;   this.cvgt[-1]=new RAT(1,0,'bot0');   this.dec;   this.rat;   this.sign="+";   this.r=0; this.n=0; this.s=1;};CF.prototype.norm=function(){   while(this.cf.length>1&&this.cfrec.length>0&&this.cf[this.cf.length-1]==this.cfrec[this.cfrec.length-1])       {//putmsg("norming");        this.cfrec.pop();this.cfrec.unshift(this.cf.pop())};  if(this.cf.length==2&&this.cf[0]==0&&this.cf[1]==1&&this.cfrec.length==0)this.cf.shift()  //0;1 -> 1 // putmsg("norms to "+this);};CF.prototype.termat=function(i){ // indexed from 0   if(i<0)HALT("CF has no term with index "+i);   if(i<this.cf.length)return this.cf[i];   if(this.isPeriodic())     return this.cfrec[(i-this.cf.length)%this.cfrec.length]   else HALT("CF has no term at index "+i);};CF.prototype.append=    function(cfterm,cvgtQ,genQ){       if(arguments.length<2)cvgtQ=false;       if(typeof cfterm=="string")cfterm=eval(cfterm);       //putmsg("append "+cfterm+" "+cvgtQ);       if(!genQ&&cfterm<0)HALT("CF terms must be positive: found "+cfterm);       if(this.cf.length>100){this.cfOFLO=true;return}       //if(this.cfint==-1)this.cfint=cfterm       //else       this.cf[this.cf.length]=cfterm;       //putmsg("this.cf is "+this.cf);       if(cvgtQ&&!this.stopped)       { if(this.cf.length==1){  this.cvgt[-1]=new RAT(1,0,'bot0');this.cvgt[0]=new RAT(cfterm,1)}         else       {     var T=this.cvgt[this.cvgt.length-1].top*cfterm+this.cvgt[this.cvgt.length-2].top,                 B=this.cvgt[this.cvgt.length-1].bot*cfterm+this.cvgt[this.cvgt.length-2].bot ;              if(isZ(B))this.cvgt[this.cvgt.length]=new RAT(T,B )               else this.cvgt.length++;           //putmsg("cvgt---"+this.cf[i]+":"+this.cvgt[this.cvgt.length-1].top+"/"+this.cvgt[this.cvgt.length-1].bot);             this.stopped = ! isZ(B) || cfterm>1e12 ||                            (this.cvgt.length>2 &&                            (    this.cvgt[this.cvgt.length-1].top/this.cvgt[this.cvgt.length-1].bot                              == this.cvgt[this.cvgt.length-2].top/this.cvgt[this.cvgt.length-2].bot));             if(this.stopped){this.cvgt.length=this.cvgt.length-1;}        }};};CF.prototype.cvgts=function(){//putmsg("periodic:"+this.isPeriodic());    this.cvgt.length=0;    this.cvgt[-1]=new RAT(1,0,'bot0');this.cvgt[0]=new RAT(this.cf[0],1);    var num1=1,den1=0,                 num0=this.cf[0],den0=1, newnum,newden;    for(var i=1; !this.stopped && (this.isPeriodic()||i<this.cf.length)&&i<40; i++)    { //putmsg("cvgt@"+i+" = "+this.termat(i));     // num and den can both be neg with negCF!!     this.cvgt[this.cvgt.length]=new RAT(newnum=num0*this.termat(i)+num1,                                         newden=den0*this.termat(i)+den1  );           // putmsg("cvgt: "+this.termat(i)+":"+this.cvgt[this.cvgt.length-1]+" = "+newnum+"/"+newden+" "+[num1,den1,num0,den0]);             this.stopped = (this.cvgt.length>2 &&den1!=0&&den0!=0                            ? Math.abs(   num1/den1 - num0/den0) <1e-15                            :false);               num1=num0;num0=newnum;  den1=den0;den0=newden;             if(this.stopped){this.cvgt.length=this.cvgt.length-1;}    };  //putmsg("CVGTS......"+this.cvgt);         //cfSHOW();};CF.prototype.reset=  function(){ this.cf=new Array(); this.cvgt=new Array();this.stopped=false; //this.cvgtUPB=-1;              this.cfrec=new Array(); this.cfOFLO=false;              this.cvgt[-1]=new RAT(1,0,'bot0');this.dec=0;this.rat=new RAT(1,0,'bot0');              this.r=0;this.n=0;this.s=1            };CF.prototype.isUnset=function(){return this.cf.length==0 //||this.cf.length==1&&this.cf[0]==0&&this.cfrec.length==0};CF.prototype.isSimple=  function(){ // all terms are positive, except first which may be 0   var found=false;   if(this.cf[0]<0)return false;   for(var i=1;!found&&i<this.cf.length;i++)     if(this.cf[i]<1)found=true;    if(found)return false;    for(var i=0;!found&&i<this.cfrec.length;i++)      if(this.cfrec[i]<1)found=true;    return !found}CF.prototype.lastcf=  function(){return this.cf[this.cf.length-1]};CF.prototype.pop=  function(){ if(this.stopped || this.cf.length==0 || this.isPeriodic() )return;  var x=this.lastcf(); //this.cvgt.length=this.cvgt.length-1;  this.cf.length=this.cf.length-1;  return x };CF.prototype.altcf= function(){//putmsg("CF---altcf of "+this.cftoString());   if(this.stopped )halt("The CF is not exact so has no alternate form");   if(this.cf.length==0 )halt("The CF has no value");   if(this.isZero())halt("The CF is 0 and has no alternate form");   if(this.isPeriodic())halt("The CF is periodic so never ends");   var last=this.pop();   if(this.cf.length>0&&last==1)this.append(this.pop()+1)   else{this.append(last-1);this.append(1)}   return true; };CF.prototype.isZero=function(){return this.cf.length==1&&this.cf[0]==0&&this.cfrec.length==0};CF.prototype.isPeriodic=  function(){return this.cfrec.length>0};CF.prototype.cftoString= function(compactQ){ //alert("PERIODIC? "+this.isPeriodic()+" "+this.cfperiodLWB+".."+this.cfperiodUPB);   //putmsg(this.isPeriodic()+" "+this.cfrec +" stp="+this.stopped);  if(arguments.length==0)compactQ=true;  var s=(this.sign=="-"?"-":"")+    (this.cf.length>0    ?(compactQ?"[":"[ ")+this.cf[0]+(compactQ?";":"; ")+this.cf.slice(1).join((compactQ?",":", "))    :"[");  if(this.isPeriodic())    {if(this.cf.length>1)s=s+",";     s=s+(compactQ?"":" ")+"<span class=overline>"+ this.cfrec.join((compactQ?",":", "))+"</span>"    }  else if(this.stopped) s+=", ...";  s=s+(compactQ?"]":" ]")  return s.replace(/-/g,"&minus;") };CF.prototype.cvgtstoString=  function(tblQ){var s=""  if(arguments.length==0)tblQ=false;      //Cf.cvgt.slice(0,this.cvgtUPB+1).join(", ")+(this.stopped?" ...":"");    if(tblQ)    {   s="<b>"+this.toString(true)+"</b>"+      "<table style='color:inherit;font-size:inherit;' class='resTBL col1borderR' cellspacing=0 cellpadding=0 >"+    "<tr><th>CF</th><td colspan=4 class=center>Convergent</td></tr>";		for(i=0;i<this.cvgt.length;i++)			  s=s+"<tr><th class=right>"+this.termat(i)+"</th><td class=right>"+"&nbsp;"+this.cvgt[i].num+"</td><td>/</td><td>"+this.cvgt[i].den+"</td><td>&nbsp;= "+this.cvgt[i].top/this.cvgt[i].bot+"</td></tr>";		if(this.stopped)s+="<tr><td>...</td></tr>"		s+="</table>"    }else    {for(i=0;i<this.cvgt.length;i++)          s=s+this.termat(i)+": "+this.cvgt[i]+" = "+this.cvgt[i].top/this.cvgt[i].bot+"<br>";     if(this.stopped)s=s+"...<br>"     };   return s};CF.prototype.toRAT=function(){ // putmsg("cf.toRAT: "+this.cf);    if(this.cf.length==1)      {if(this.cf[0]==0)this.r=Infinity       else this.r=new RAT(this.cf[0],1)}    else { var rnum=1,rden=this.cf[this.cf.length-1],d;		for(i=this.cf.length-2;i>0;i--)		 { //putmsg(rden+"/"+(rden*this.cf[i]+rnum));		   d=rden;rden=rden*this.cf[i]+rnum;rnum=d;		   d=gcd(rnum,rden);rnum=rnum/d;rden=rden/d		   };		if(this.cf.length==1)this.r=this.cf[0]		else if(rden!=0) this.r=RATadd(this.cf[0],new RAT(rnum,rden))		else if(rnum==0){this.r= Number.NaN}		else this.r=(rnum<0?-Infinity:Infinity);	   //putmsg("toRAT <- "+this.r);   };   return this.r };CF.prototype.toDec=   function(){  //if(this.cvgt.length==0)this.cvgts();  //return this.cvgt[this.cvgt.length].val  //putmsg(this+" dec="+this.toRAT().val)  var v=this.toRAT();  return (v.val?v.val:v)  };CF.prototype.toString=  function(compactQ){if(arguments.length==0)compactQ=false;   return this.cftoString(compactQ)};CF.prototype.dump=function(){return "===DUMP cf="+this.cf.join(",")+   "["+this.cfrec.join(",")+"]<br> "+this.cvgt.length+"=#cvgt "+  "  stopped="+this.stopped+" OFLO="+this.cfOFLO   +" 0?="+this.isZero()+"<br>=====<br>"};function ArrayToCF(row){  var cf=new CF();  for(var i=0;i<row.length;i++)cf.append(row[i],true,true);  return cf};function Real2Rat(r){   var nbterms=0,p10=0,den=1,rr;   with(Math){while(isInt(den*10)&&(r*den-floor(r*den)>0)&&isInt(round(r*den*10))){den*=10}}; //putmsg("Real2Rat "+r+" "+(round(r*den)-Math.floor(r*den))+" isInt :"+[isInt(round(r*den)),isInt(den)])   rr=new RAT(round(r*den),den)   //trace("Real2Rat "+r+" -> "+rr)   return rr};CF.prototype.fromRAT=function(f){ //!!! Usage: cf=new CF(); cf.fromRAT(rat)    //trace("fromRAT "+f)    var r=f.num,t=f.num,b=f.den,s=f.den,i=-1,q;   if(r<0){this.sign="-";r=-r}   do{ q=Math.floor(t/b);       r=t-q*b;       if(!isInt(q)||q>1e12)r=0       else{this.append(q);            t=b;b=r};   } while (r>1e-15 && !this.stopped);   //alert("rat2cf "+f+" -> "+this.cftoString());  // this.cvgts();  // putmsg("fromRAT Cf length="+Cf.cf.length+" := "+Cf.cvgt.length+" "+Cf)  // this.cf.length=this.cvgt.length};function changeMinus(str){ //replace HTML &minus; in str to "-"    return str.replace(/./g,function(char){    if(unescape(char)==unescape("%u2212")) return '-';     return char;}) }    function StringToCF(cfwf,cfr,genQ){ //   cfw=whole;fixed part    cfr=repeating part   if(arguments.length<3)genQ=false;   if(arguments.length<2)cfr="";   cfwf=cfwf.replace(/\s/g,"");   cfr=cfr.replace(/\.\.\./,"").replace(/\s/g,"")   if(cfr.indexOf("-")>-1)HALT("!! In this version, the periodic part cannot contain negative numbers - sorry.");  var cff,cfw, semiat=cfwf.indexOf(";");  if(cfwf==""&&cfr=="")halt(" There is no continued Fraction: input is empty");  if(semiat==-1)halt("You must include a whole number part as a number followed by a semicolon(;)");  cfw=cfwf.slice(0,semiat);  if(cfw.indexOf(",")!=-1)halt("There must be only one number before the semicolon (the integer part of the fraction)");  cff=cfwf.slice(semiat+1); //putmsg([cff,cfw,cfr]);  if(cff==""&&cfw==0&&cfr=="")HALT("The CF is 0; it must contain some non-zero values")  cfw=changeMinus(cfw);cff=changeMinus(cff);cfr=changeMinus(cfr);  //putmsg("whole="+cfw+" fxd="+cff+" rep="+cfr);  try{cfw=eval(cfw);if(!isInt(cfw))halt("The whole part before the semicolon is not a number: "+cfw)}  catch(e){halt("The part before the semicolon is not a number: "+cfw)};  try{cff=eval("["+cff+"]"); //alert("fxd part is "+telltype(cff));      if(telltype(cff)!="array")halt("only numbers and commas are allowed in the CF fixed part")}  catch(e){halt("The CF is not a list of numbers after the semicolon")};  if(!genQ&&Arraypos(0,cfr)!=-1)HALT("The repeating part cannot contain a 0 term");  try{cfr=(cfr.length==0?"":eval("["+cfr+"]"))}  catch(e){halt("The repeating part must be a list numbers separated by a comma")};  //if(telltype(cfr)!="array")halt("only numbers and commas are allowed in the CF repeating part");  //putmsg("$StringtoCF from IN: w="+cfw+" fxd="+cff+" cfr="+cfr);  var Cf=new CF();  Cf.append(cfw,false,genQ);  for(var i=0;i<cff.length;i++)          if(!isInt( cff[i]))                 HALT("This item in your CF is not a whole number:\r"+cff[i])     else if(!genQ&&cff[i]==0 && i>0)         HALT("Only the first number in your CF can be 0.")     else if(!genQ&&cff[i]<0)                 HALT("You cannot have negative numbers in your CF.\rI found "+cff[i])     else  Cf.append(cff[i],false,genQ);  Cf.cfrec=cfr.slice();  Cf.norm();  //putmsg("newCF "+Cf);  return Cf}CF.prototype.sum=function(){var tot=0;  for(var i=0;i<this.cf.length;i++)tot+=this.cf[i];  return tot};CF.prototype.reverse=function(){  //putmsg("rving "+this); var CFR=new CF(); var cfR=this.cf.slice(1); //putmsg("cfR "+cfR+" whole="+this.cf[0]); CFR.cf=cfR.slice();  CFR.cf.reverse(); //putmsg("cfRrev "+CFR.cf); CFR.cf.unshift(this.cf[0]); //putmsg("cfrev cf "+CFR.cf)// putmsg("reving rec:["+this.cfrec+"]") if(this.cfrec.length>0){CFR.cfrec=this.cfrec.slice();  CFR.cfrec.reverse();}; //putmsg("cfrev cfrec "+CFR.cfrec); //putmsg("rev  <- "+CFR); return CFR};